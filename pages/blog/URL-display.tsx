import { Footer } from "antd/lib/layout/layout";
import Head from "next/head";
import React from "react";
import styles from "./HTTP-status-code.module.css";
const Display = () => {
  return (
    <>
      <Head>
        <title>URL-display</title>
        <link rel="icon" href="/favicon.png" />
      </Head>
      <main className={styles.container}>
        <div>
          <p className={styles.title}>
            从输入一个URL到页面展示之间发生了什么？
          </p>
          <br />
          <div className={styles.content}>
            <p>
              “请说一下从输入一个URL到页面展示的过程...”
              这样的面试题相信大家都经常遇到吧。作为面试高频题，同时也是作为浏览器网络的基础，掌握整个过程
              也是十分重要的。敲重点，快来学习!
            </p>
            <br />
            <p>
              <h2>导航</h2>
              <p>从用户发出URL请求到页面开始解析的整个过程，称之为导航。</p>
              <h4>1. 用户输入</h4>
              <ul>
                <li>
                  当用户在地址栏输入一个查询关键字，地址栏会判断输入内容是URL还是搜索内容。如果为搜索内容，则会使用浏览器默认的搜索引擎来合成新的带搜索内容的URL。若为URL则合成完整的URL。
                  在替换成新的页面之前，浏览器会给当前页面一个 beforeunload
                  事件的机会，允许页面在退出之间做一些操作，比如会查询用户是否确定要离开等。
                </li>
                <li>进入加载状态 loading</li>
              </ul>
              <h4>2. URL 请求过程</h4>
              <ul>
                <li>
                  浏览器进程通过IPC(进程间通信)将 URL 请求信息发送至网络进程。
                </li>
                <li>
                  网络进程接收到请求信息之后，发起真正的URL请求。首先网络进程会查询本地缓存是否缓存了本资源。如果有缓存资源，那么直接返回资源给浏览器进程，如果缓存中没有找到资源，那么直接进入网络请求流程。
                </li>
                <li>DNS解析，获取请求域名的服务器的IP地址</li>
                <li>和目标服务器建立 TCP 连接</li>
                <li>浏览器构建HTTP请求信息，向服务器发送请求。</li>
                <li>服务器处理请求，生成相应信息并发送给浏览器。</li>
                <li>
                  浏览器接收到响应信息后，识别响应信息。如果响应状态码为301或者302则代表服务器需求浏览器需要重定向到其他URL，根据响应头字段中的Location字段读取重定向的地址，重新发起请求。
                </li>
                <li>
                  响应信息的处理。通过 Content-Type
                  字段可以判断相应体的数据类型，决定如何显示相应体的数据。
                </li>
              </ul>
              <h4>3. 准备渲染进程</h4>
              <p>
                通常情况下，打开新的标签页会采取单独的渲染进程：如果从A页面打开B页面，且A页面和B页面都是属于同一站点，那么B页面会复用A页面的渲染进程。否则，浏览器会为B页面创建一个新的渲染进程。
              </p>
              <h4>4. 提交文档</h4>
              <p>浏览器进程将接收到的HTML文件提交给渲染进程，准备渲染页面。</p>
            </p>
            <h2>渲染页面</h2>
            <p>
              渲染页面的过程可以分为以下各个部分：构建DOM树，样式计算，布局，分层，绘制，分块，光栅化，合成。下面我们将分别介绍各个部分中完成的部分。
            </p>
            <h4>5.构建DOM树</h4>
            <p>为什么需要构建DOM树？ 这是因为浏览器无法直接理解和使用HTML，所以需要将HTML文件转换为浏览器可以理解的DOM树的结构。DOM结构为树结构，根据HTML文件的结构，有父节点和子节点</p>
            <h4>6.样式计算</h4>
            <ul>
                <li>将css转换为浏览器可以理解的styleSheets结构</li>
                <li>计算每个节点的样式，标准化样式。</li>
            </ul>
            <h4>7. 布局阶段</h4>
            <ul>
                <li>创建布局树</li>
                <p>通过遍历DOM树中的所有节点，将可见的节点添加到布局树中，并对节点添加相应的样式。</p>
                <p>布局计算。在执行布局操作的过程中，会把布局计算之后的结果重新写回到布局树中，所以这里的布局树既是输出的内容也是输入的内容，这是布局中相对不合理的一个地方。当然Chrome团队也在下一代的布局系统中做出完善</p>
                <li>分层</li>
                <p>浏览器页面中看到的内容是很多的样式图层重叠在一起构成了最终的页面。所以在渲染过程中需要单独渲染单独的每个图层。</p>
                <ul>
                    <li>构建布局树对应的图层树。并不是布局树中的每一个节点都包含一个图层。如果一个节点没有对应的层，那么这个节点就属于副节点的图层。拥有层叠上下文的元素会被单独提升为一个图层，比如有z-index属性的元素就会单独有一个图层</li>
                    <li>图层绘制。为每个图层常见一个绘制列表，将一个图层的绘制拆分成很多的小的绘制指令，然后把这些指令放入一个列表中。这一操作并不会真正执行绘制的操作。</li>
                </ul>
                <li>栅格化</li>
                <p>合成现成将图层划分为图块，然后合成线程会按照视口附近的图块来优先生成位图</p>
                <li>合成和显示</li>
                <p>一旦多有的图块都被栅格化，合成线程就会生成一个绘制图块的mingl“DrawQuad”，然后该命令提交给浏览器进程，根据DrawQuad命令，将页面内容绘制到内存中，最后将内存中的内容显示在页面上</p>
            </ul>
            <p>这就是整个从URL输入到页面展示的过程。关于导航部分的具体细节，将会在之后的文章中详细讨论。</p>
          </div>
        </div>
        <Footer>
          <p className={styles.time}>2022-10-20</p>
        </Footer>
      </main>
    </>
  );
};

export default Display;
